<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI/Human Text Classifier - TensorFlow.js</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ¤–</text></svg>">
    
    <!-- Load TensorFlow.js, tfjs-vis, PapaParse (for CSV), and Tailwind CSS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom scrollbar and link color matching the primary blue */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        .container {
            font-family: 'Inter', sans-serif;
        }
        .text-primary { color: #1a73e8; }
        .bg-primary { background-color: #1a73e8; }
        .bg-primary-hover:hover { background-color: #0d62c9; }
        
        /* Ensures tfjs-vis visualizations are responsive */
        #charts, #training-vis {
            width: 100%;
            min-height: 400px;
        }
        /* Custom height for Confusion Matrix text box */
        #confusion-matrix {
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Responsive table for data preview */
        .data-preview table {
            min-width: 600px;
        }
        
        /* Disabled state styling */
        .bg-gray-400 {
            cursor: not-allowed;
        }
        
    </style>
</head>
<body class="bg-gray-50 text-gray-800 p-4 sm:p-8">
    <div class="container mx-auto max-w-7xl">
        <header class="mb-8">
            <h1 class="text-4xl font-extrabold text-primary mb-2">AI/Human Text Classifier with TensorFlow.js</h1>
            <p class="text-gray-600">A step-by-step deep learning workflow for natural language processing entirely in the browser.</p>
        </header>
        
        <!-- ================================== 1. DATA LOAD ================================== -->
        <section id="data-load" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">1. Data Load & Column Fix</h2>
            <p class="mb-4 text-gray-600">The code is now optimized to automatically find the **Label (0/1)** in the second column and the main **Text Content** in the final column of your CSV.</p>
            
            <div class="space-y-4">
                <div class="flex flex-col sm:flex-row sm:items-center">
                    <label for="train-file" class="w-48 font-medium">Training Data (train.csv):</label>
                    <input type="file" id="train-file" accept=".csv" class="ml-0 sm:ml-4 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-white hover:file:bg-blue-600">
                </div>
                <div class="flex flex-col sm:flex-row sm:items-center">
                    <label for="test-file" class="w-48 font-medium">Prediction Data (test.csv):</label>
                    <input type="file" id="test-file" accept=".csv" class="ml-0 sm:ml-4 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-white hover:file:bg-blue-600">
                </div>
            </div>
            
            <button id="load-data-btn" onclick="handleLoadData()" class="mt-6 px-6 py-2 rounded-full bg-primary text-white font-bold transition duration-150 bg-primary-hover">Load Data</button>
            <div id="data-status" class="mt-4 font-medium"></div>
        </section>

        <!-- ================================== 2. DATA INSPECTION ================================== -->
        <section id="inspect" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">2. Data Inspection</h2>
            <button id="inspect-btn" onclick="inspectData()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Inspect Data</button>
            
            <div id="data-stats" class="mt-4 p-4 border border-gray-200 rounded-lg"></div>
            
            <h3 class="text-xl font-semibold mt-6 mb-3">Data Preview (Train Set)</h3>
            <div id="data-preview" class="data-preview overflow-x-auto border rounded-lg p-2"></div>
            
            <h3 class="text-xl font-semibold mt-6 mb-3">Class Balance Visualization</h3>
            <div id="charts" class="border rounded-lg p-2"></div>
        </section>

        <!-- ================================== 3. PREPROCESSING & TOKENIZATION ================================== -->
        <section id="preprocessing" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">3. Preprocessing & Tokenization</h2>
            <p class="mb-4 text-gray-600">Define parameters for tokenizing and padding the text sequences.</p>
            
            <div class="flex flex-wrap gap-6 mb-6">
                <div class="flex flex-col">
                    <label for="max-len" class="font-medium">Max Sequence Length:</label>
                    <input type="number" id="max-len" value="100" min="10" max="500" class="mt-1 p-2 border border-gray-300 rounded-lg w-32">
                    <p class="text-xs text-gray-500 mt-1">Shorter texts will be padded; longer texts truncated.</p>
                </div>
                <div class="flex flex-col">
                    <label for="embedding-dim" class="font-medium">Embedding Dimension:</label>
                    <input type="number" id="embedding-dim" value="32" min="8" max="128" class="mt-1 p-2 border border-gray-300 rounded-lg w-32">
                    <p class="text-xs text-gray-500 mt-1">Size of the word embedding vectors.</p>
                </div>
            </div>
            
            <button id="preprocess-btn" onclick="preprocessData()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Preprocess Data (80/20 Split)</button>
            <div id="preprocessing-output" class="mt-4 font-medium"></div>
        </section>

        <!-- ================================== 4. TEXT EMBEDDING ================================== -->
        <section id="embedding" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">4. Text Embedding</h2>
            <p class="mb-4">The first layer in the model converts the token indices into dense numerical vectors. This step determines the final vocabulary size.</p>
            
            <button id="create-embedding-btn" onclick="createEmbeddingModel()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Define Vocabulary & Embedding</button>
            <div id="embedding-status" class="mt-4 font-medium"></div>
        </section>

        <!-- ================================== 5. MODEL SETUP ================================== -->
        <section id="model" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">5. Model Setup (CNN/MaxPool)</h2>
            <button id="create-model-btn" onclick="createModel()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Create Model</button>
            <div id="model-summary" class="mt-4 p-4 bg-gray-100 rounded-lg overflow-x-auto"></div>
        </section>

        <!-- ================================== 6. TRAINING ================================== -->
        <section id="training" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">6. Training</h2>
            <p class="mb-4">Monitor the loss and accuracy (including validation metrics) below during training.</p>
            <button id="train-btn" onclick="trainModel()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Train Model</button>
            
            <div id="training-status" class="mt-4 font-medium"></div>
            <div id="training-vis" class="mt-4 border rounded-lg p-2"></div>
        </section>
        
        <!-- ================================== 7. LIVE PREDICTION ================================== -->
        <section id="live-prediction" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">7. Live Prediction</h2>
            <p class="mb-4 text-gray-600">Enter a block of text to predict its origin (AI or Human).</p>
            
            <textarea id="user-text-input" rows="5" placeholder="Enter text here..." class="p-3 border border-gray-300 rounded-lg w-full focus:ring-primary focus:border-primary transition duration-150"></textarea>
            
            <button id="live-predict-btn" onclick="predictLive()" disabled class="mt-3 px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Predict Probability (%)</button>
            
            <div id="live-prediction-output" class="mt-4 p-4 border border-blue-200 bg-blue-50 rounded-lg hidden">
                <h3 class="font-bold text-lg mb-1">Result: <span id="live-result-label" class="text-primary"></span></h3>
                <p>Confidence: <span id="live-result-conf" class="font-mono text-gray-700"></span></p>
            </div>
        </section>

        <!-- ================================== 8. EVALUATION & METRICS ================================== -->
        <section id="metrics" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">8. Evaluation & Metrics (<span class="text-green-600">Validation Set</span>)</h2>
            <button id="evaluate-btn" onclick="evaluateModel()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Evaluate on Validation Data</button>
            <div id="prediction-output" class="mt-4 font-medium"></div>

            <div class="slider-container mt-6">
                <label for="threshold-slider" class="font-medium flex justify-between items-center">
                    Classification Threshold: 
                    <span id="threshold-value" class="font-mono text-primary">0.50</span>
                </label>
                <input type="range" id="threshold-slider" class="slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg mt-2" min="0" max="1" step="0.01" value="0.5" disabled oninput="calculateMetrics()">
            </div>
            
            <div id="metrics-output" class="metrics-container flex flex-wrap gap-4 mt-6">
                <div class="metric-card border border-gray-200 p-4 rounded-lg flex-1 min-w-[280px]">
                    <h3 class="text-xl font-semibold mb-3">Performance Metrics</h3>
                    <div id="performance-metrics"></div>
                </div>
                <div class="metric-card border border-gray-200 p-4 rounded-lg flex-1 min-w-[280px]">
                    <h3 class="text-xl font-semibold mb-3">Confusion Matrix (Threshold: 0.50)</h3>
                    <div id="confusion-matrix" class="font-mono text-sm"></div>
                </div>
            </div>
        </section>

        <!-- ================================== 9. EXPORT RESULTS ================================== -->
        <section id="export" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-primary mb-4">9. Export Predictions (on test.csv)</h2>
            <button id="export-btn" onclick="exportResults()" disabled class="px-6 py-2 rounded-full bg-gray-400 text-white font-bold transition duration-150 disabled:opacity-50">Generate Prediction Results CSV</button>
            <div id="export-status" class="mt-4 font-medium"></div>
        </section>
        
    </div>

<script>
    // ==================================================================================
    // APP.JS LOGIC - Integrated into a single file for the Canvas environment
    // ==================================================================================

    // Global State Variables
    let trainData = null; // Stored as [[Label, Text], ...]
    let testData = null;  // Stored as [[Label, Text], ...]
    let model = null;
    let tokenizer = null;
    
    // Tensors for Training and Validation
    let xTrain, yTrain, xVal, yVal; 
    
    // Raw Data and Padded Sequences for Test Set
    let testSequencesPadded;
    let valProbAI; // Model predictions on the validation set

    // Hyperparameters - Initialized to reflect the UI
    let MAX_LEN = 100;
    let EMBEDDING_DIM = 32;
    const VOCAB_SIZE = 20000; 

    // Utility Functions
    const enableButton = (id, state) => {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.disabled = !state;
        if (state) {
            btn.classList.remove('bg-gray-400', 'cursor-not-allowed');
            btn.classList.add('bg-primary', 'bg-primary-hover');
        } else {
            btn.classList.remove('bg-primary', 'bg-primary-hover');
            btn.classList.add('bg-gray-400', 'cursor-not-allowed');
        }
    };

    const updateStatus = (id, message, isError = false) => {
        const el = document.getElementById(id);
        el.className = 'mt-4 font-medium ' + (isError ? 'text-red-600' : 'text-green-600');
        el.innerText = message;
    };
    
    /**
     * Cleans text that is highly quoted (a common CSV artifact).
     * @param {string} text - The raw text from the CSV cell.
     * @returns {string} The cleaned text.
     */
    const cleanTextContent = (text) => {
        let s = String(text || '').trim();
        // Remove outer brackets and excess quotes if present: '[""content""]'
        if (s.startsWith('[""') && s.endsWith('""]')) {
            s = s.substring(3, s.length - 3);
        } else if (s.startsWith('"') && s.endsWith('"')) {
            s = s.substring(1, s.length - 1);
        }
        // Remove escaped newlines and internal escaped quotes
        s = s.replace(/\\n/g, ' ').replace(/\\\"/g, '"');
        return s.trim();
    };

    /**
     * Reads and parses a CSV file using PapaParse, extracting only the Label (Col 2 / Index 1) 
     * and the main Text Content (Last Column).
     * @param {File} file - The uploaded CSV file.
     * @returns {Promise<Array<Array<string>>>} The cleaned data array [[Label, Text], ...]
     */
    const loadCSVAndClean = (file) => new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: false,
            dynamicTyping: false,
            skipEmptyLines: true,
            complete: (results) => {
                let rows = results.data;
                if (!rows || rows.length < 2) {
                    return reject(new Error("File is too short or empty."));
                }
                
                // Skip the header row
                rows = rows.slice(1);
                const cleanedData = [];

                for (const row of rows) {
                    // We assume Label is in Column 2 (Index 1) and Text is in the last column
                    if (row.length < 2) continue;

                    const labelRaw = row[1]; // Index 1 is the Label (0 or 1)
                    const textRaw = row[row.length - 1]; // Last column is the question/content

                    // Robustly validate and clean the content
                    const label = String(labelRaw).trim();
                    let text = cleanTextContent(textRaw);
                    
                    if ((label === '0' || label === '1' || label === 0 || label === 1) && text.length > 5) {
                        // Store the data in the simple format: [Label, Text]
                        cleanedData.push([String(label), text]);
                    }
                }
                resolve(cleanedData);
            },
            error: (error) => reject(error)
        });
    });

    // ==================================================================================
    // Step 1: Data Load Handler
    // ==================================================================================
    window.handleLoadData = async () => {
        updateStatus('data-status', 'Loading data...');
        enableButton('load-data-btn', false);

        const trainFile = document.getElementById('train-file').files[0];
        const testFile = document.getElementById('test-file').files[0];

        if (!trainFile || !testFile) {
            updateStatus('data-status', 'Please upload both train.csv and test.csv.', true);
            enableButton('load-data-btn', true);
            return;
        }

        try {
            // Load and clean the data
            trainData = await loadCSVAndClean(trainFile);
            testData = await loadCSVAndClean(testFile);

            if (trainData.length === 0 || testData.length === 0) {
                throw new Error("One or both datasets are empty after cleaning. Check that labels are in column 2 and text is in the final column.");
            }

            updateStatus('data-status', 
                `âœ… Data loaded and cleaned successfully. Train samples: ${trainData.length}, Test samples: ${testData.length}.`,
                false
            );

            // Enable next step
            enableButton('inspect-btn', true);

        } catch (error) {
            console.error('Data loading error:', error);
            updateStatus('data-status', `âŒ Data loading failed: ${error.message}`, true);
            enableButton('load-data-btn', true);
        }
    };

    // ==================================================================================
    // Step 2: Data Inspection
    // ==================================================================================
    window.inspectData = async () => {
        if (!trainData || trainData.length === 0) return;
        enableButton('inspect-btn', false);

        // Data is now in the format: [[Label, Text], ...]
        const labels = trainData.map(row => parseInt(row[0]));
        const texts = trainData.map(row => row[1]); 

        const totalSamples = trainData.length;
        const humanCount = labels.filter(l => l === 0).length;
        const aiCount = labels.filter(l => l === 1).length;

        const humanPercent = ((humanCount / totalSamples) * 100);
        const aiPercent = ((aiCount / totalSamples) * 100);

        const statsHtml = `
            <p><strong>Total Cleaned Train Samples:</strong> ${totalSamples}</p>
            <p><strong>Human (Label 0) Samples:</strong> ${humanCount} (${humanPercent.toFixed(1)}%)</p>
            <p><strong>AI (Label 1) Samples:</strong> ${aiCount} (${aiPercent.toFixed(1)}%)</p>
            <p class="${(humanPercent < 40 || aiPercent < 40) ? 'text-red-500' : 'text-green-500'}">
                <strong>Class Balance:</strong> ${(humanPercent < 40 || aiPercent < 40) ? 'Imbalanced (Consider sampling methods)' : 'Balanced (Good starting point)'}
            </p>
        `;
        document.getElementById('data-stats').innerHTML = statsHtml;

        // 2. Data Preview Table
        const previewRows = trainData.slice(0, 5);
        let tableHtml = `<table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Label (0=Human, 1=AI)</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Text Content (Snippet)</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
        `;
        previewRows.forEach(row => {
            const label = row[0];
            const textContent = row[1];
            const textSnippet = textContent.substring(0, 100).replace(/\n/g, ' ') + (textContent.length > 100 ? '...' : '');

            tableHtml += `
                <tr>
                    <td class="px-6 py-4 whitespace-nowrap">${label}</td>
                    <td class="px-6 py-4 text-sm text-gray-900">${textSnippet}</td>
                </tr>
            `;
        });
        tableHtml += '</tbody></table>';
        document.getElementById('data-preview').innerHTML = tableHtml;

        // 3. Class Balance Visualization (tfjs-vis)
        const classBalanceData = [
            { index: 0, label: 'Human', value: humanCount },
            { index: 1, label: 'AI', value: aiCount }
        ];

        const surface = tfvis.visor().surface({ name: 'Class Balance', tab: 'Data' });
        tfvis.render.barchart(surface, classBalanceData, {
            title: 'AI vs. Human Sample Count',
            xLabel: 'Origin',
            yLabel: 'Count'
        });

        enableButton('preprocess-btn', true);
    };

    // ==================================================================================
    // Step 3 & 4: Preprocessing, Tokenization, & Embedding Setup
    // ==================================================================================
    window.preprocessData = async () => {
        updateStatus('preprocessing-output', 'Tokenizing data, defining vocabulary, and splitting into Train/Validation sets (80/20)...');
        enableButton('preprocess-btn', false);

        // Update Hyperparameters from UI
        MAX_LEN = parseInt(document.getElementById('max-len').value);
        EMBEDDING_DIM = parseInt(document.getElementById('embedding-dim').value);
        
        // 1. Separate features (text) and labels from the cleaned data
        const allTrainTexts = trainData.map(row => row[1]);
        const allTrainLabels = trainData.map(row => parseInt(row[0]));
        
        // Raw test data texts
        const xTestRaw = testData.map(row => row[1]); 

        // 1.1 SPLIT TRAIN DATA (80% Train, 20% Validation)
        const splitIndex = Math.floor(allTrainTexts.length * 0.8);

        const rawTrainTexts = allTrainTexts.slice(0, splitIndex);
        const rawTrainLabels = allTrainLabels.slice(0, splitIndex);

        const rawValTexts = allTrainTexts.slice(splitIndex);
        const rawValLabels = allTrainLabels.slice(splitIndex);

        // 2. Tokenization - Create Vocabulary (fit only on RAW TRAIN texts)
        tokenizer = new tf.data.Tokenizer({ numWords: VOCAB_SIZE });
        tokenizer.fitOnTexts(rawTrainTexts);

        // 3. Convert texts to sequences of integers
        const trainSequences = tokenizer.textsToSequences(rawTrainTexts);
        const valSequences = tokenizer.textsToSequences(rawValTexts);
        const testSequences = tokenizer.textsToSequences(xTestRaw);

        // 4. Padding/Truncation
        xTrain = tf.data.sequence.padSequences(trainSequences, { maxLen: MAX_LEN });
        xVal = tf.data.sequence.padSequences(valSequences, { maxLen: MAX_LEN });
        testSequencesPadded = tf.data.sequence.padSequences(testSequences, { maxLen: MAX_LEN });
        
        // 5. Convert labels to one-hot tensors
        const trainLabelsTensor = tf.tensor1d(rawTrainLabels, 'int32');
        yTrain = tf.oneHot(trainLabelsTensor, 2);

        const valLabelsTensor = tf.tensor1d(rawValLabels, 'int32');
        yVal = tf.oneHot(valLabelsTensor, 2);

        // Clean up memory
        trainLabelsTensor.dispose();
        valLabelsTensor.dispose();

        updateStatus('preprocessing-output', 
            `âœ… Preprocessing complete. Train samples: ${rawTrainTexts.length}, Validation samples: ${rawValTexts.length}.`,
            false
        );
        
        // Enable Embedding step
        enableButton('create-embedding-btn', true);
        
        // Update model params display
        document.getElementById('embedding-status').innerHTML = `<p class="mt-2">Estimated Vocabulary Size (tokens): <strong>${tokenizer.wordIndex.length}</strong></p><p>Embedding Dimension: <strong>${EMBEDDING_DIM}</strong></p>`;
    };

    window.createEmbeddingModel = async () => {
        enableButton('create-embedding-btn', false);
        document.getElementById('embedding-status').innerHTML += `<p class="text-green-600 font-bold mt-2">âœ… Embedding parameters finalized. Ready for Model Setup.</p>`;
        enableButton('create-model-btn', true);
    }

    // ==================================================================================
    // Step 5: Model Setup
    // ==================================================================================
    window.createModel = async () => {
        if (!xTrain) {
            updateStatus('model-summary', 'Please preprocess data first.', true);
            return;
        }
        enableButton('create-model-btn', false);
        document.getElementById('model-summary').innerText = 'Building model...';

        tf.tidy(() => {
            const vocabSize = tokenizer.wordIndex.length + 1; // +1 for padding/unknown

            model = tf.sequential();
            
            // 1. Embedding Layer: Converts token indices to dense vectors
            model.add(tf.layers.embedding({
                inputDim: vocabSize,
                outputDim: EMBEDDING_DIM,
                inputLength: MAX_LEN
            }));

            // 2. Convolutional Layer for feature extraction
            model.add(tf.layers.conv1d({
                filters: 128,
                kernelSize: 5,
                activation: 'relu'
            }));
            
            // 3. Global Max Pooling to reduce feature dimension
            model.add(tf.layers.globalMaxPool1d({}));

            // 4. Dense Layer
            model.add(tf.layers.dense({ units: 10, activation: 'relu' }));
            
            // 5. Dropout for regularization
            model.add(tf.layers.dropout({ rate: 0.5 }));

            // 6. Output Layer: Softmax for binary classification (2 units for one-hot encoding)
            model.add(tf.layers.dense({
                units: 2,
                activation: 'softmax'
            }));

            // Compile the model
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
        });

        // Display model summary (tfjs-vis)
        const summarySurface = tfvis.visor().surface({ name: 'Model Summary', tab: 'Model' });
        tfvis.show.modelSummary(summarySurface, model);
        document.getElementById('model-summary').innerText = 'âœ… Model built and compiled successfully. Check the "Model" tab for details.';
        
        enableButton('train-btn', true);
        enableButton('live-predict-btn', true); 
    };

    // ==================================================================================
    // Step 6: Training
    // ==================================================================================
    window.trainModel = async () => {
        if (!model || !xTrain) return;

        enableButton('train-btn', false);
        document.getElementById('training-status').innerText = 'Training in progress... (This may take several minutes)';

        const params = { epochs: 10, batchSize: 32 };

        const trainSurface = tfvis.visor().surface({ name: 'Model Training', tab: 'Training' });
        await model.fit(xTrain, yTrain, {
            epochs: params.epochs,
            batchSize: params.batchSize,
            shuffle: true,
            validationData: [xVal, yVal], // Use validation data for monitoring
            callbacks: tfvis.show.fitCallbacks(
                trainSurface,
                ['loss', 'acc', 'val_loss', 'val_acc'], // Display validation metrics
                { callbacks: ['onEpochEnd'] }
            )
        });

        document.getElementById('training-status').innerText = 'âœ… Training complete!';
        
        // Enable prediction steps
        enableButton('evaluate-btn', true);
    };


    // ==================================================================================
    // Step 7: Live Prediction (User Input)
    // ==================================================================================
    window.predictLive = async () => {
        if (!model || !tokenizer) {
            updateStatus('live-prediction-output', 'Model not ready. Please complete training.', true);
            document.getElementById('live-prediction-output').classList.remove('hidden');
            return;
        }
        
        const text = document.getElementById('user-text-input').value;
        const outputDiv = document.getElementById('live-prediction-output');
        
        if (text.trim().length === 0) {
            updateStatus('live-prediction-output', 'Please enter some text.', true);
            outputDiv.classList.remove('hidden');
            return;
        }

        enableButton('live-predict-btn', false);
        outputDiv.classList.add('hidden');

        await tf.nextFrame();

        tf.tidy(() => {
            const sequence = tokenizer.textsToSequences([text]);
            const paddedSequence = tf.data.sequence.padSequences(sequence, { maxLen: MAX_LEN });
            const inputTensor = tf.tensor2d(paddedSequence, [1, MAX_LEN]);

            const prediction = model.predict(inputTensor);
            const probAI = prediction.dataSync()[1]; // Probability for class 1 (AI)
            const probHuman = prediction.dataSync()[0]; // Probability for class 0 (Human)

            const confidence = Math.max(probAI, probHuman) * 100;
            const label = probAI > 0.5 ? 'AI Generated (1)' : 'Human Generated (0)';
            const colorClass = probAI > 0.5 ? 'text-red-600' : 'text-green-600';

            document.getElementById('live-result-label').innerText = label;
            document.getElementById('live-result-label').className = colorClass;
            document.getElementById('live-result-conf').innerText = `${confidence.toFixed(2)}%`;

            outputDiv.classList.remove('hidden');
            outputDiv.classList.remove('bg-blue-50', 'border-blue-200', 'bg-red-50', 'bg-green-50');
            outputDiv.classList.add(probAI > 0.5 ? 'bg-red-50' : 'bg-green-50', probAI > 0.5 ? 'border-red-200' : 'border-green-200');
            
            inputTensor.dispose();
            prediction.dispose();
        });

        enableButton('live-predict-btn', true);
    };

    // ==================================================================================
    // Step 8: Evaluation & Metrics (on Validation Set)
    // ==================================================================================
    window.evaluateModel = async () => {
        if (!model || !xVal) return;
        enableButton('evaluate-btn', false);
        document.getElementById('prediction-output').innerText = 'Running predictions on validation set...';

        await tf.nextFrame();

        tf.tidy(() => {
            // Predict on the validation set (xVal)
            const rawValPredictions = model.predict(xVal);
            
            // Extract probability for class 1 (AI)
            // Note: rawValPredictions is a 2D tensor [num_samples, 2]
            valProbAI = rawValPredictions.slice([0, 1], [-1, 1]); 
            
            // Initial metric calculation
            calculateMetrics();

            document.getElementById('prediction-output').innerText = 'âœ… Evaluation complete on Validation set. Adjust threshold to view metrics.';
            document.getElementById('threshold-slider').disabled = false;
            enableButton('export-btn', true); 
        });

        enableButton('evaluate-btn', true);
    };


    window.calculateMetrics = () => {
        if (!valProbAI) return;

        tf.tidy(() => {
            const threshold = parseFloat(document.getElementById('threshold-slider').value);
            document.getElementById('threshold-value').innerText = threshold.toFixed(2);

            // True labels are derived from the yVal one-hot tensor
            const trueLabels = yVal.argMax(1); 
            
            // Convert probabilities to binary predictions based on threshold
            const predLabels = valProbAI.greater(threshold).cast('int32');
            
            // 1. Confusion Matrix
            // tfvis.metrics.confusionMatrix expects true labels and predicted labels
            const confusionMatrix = tfvis.metrics.confusionMatrix(trueLabels, predLabels, 2);
            // TN=0, FP=1, FN=2, TP=3 (flat array indices)
            const [TN, FP, FN, TP] = confusionMatrix.dataSync();

            const matrixHtml = `
                <div class="grid grid-cols-2 gap-2 text-center text-sm">
                    <div class="p-2 border bg-gray-100 font-bold col-span-2">Predicted</div>
                    <div class="p-2 border bg-gray-100">Negative (0)</div>
                    <div class="p-2 border bg-gray-100">Positive (1)</div>
                    
                    <div class="p-2 border bg-gray-100 row-span-2 flex items-center justify-center font-bold">Actual</div>
                    <div class="p-2 border">TN: ${TN}</div>
                    <div class="p-2 border text-red-600">FP: ${FP}</div>
                    
                    <div class="p-2 border text-red-600">FN: ${FN}</div>
                    <div class="p-2 border">TP: ${TP}</div>
                </div>
            `;
            document.getElementById('confusion-matrix').innerHTML = matrixHtml;
            
            // 2. Performance Metrics
            const ACCURACY = (TP + TN) / (TP + TN + FP + FN) || 0;
            const PRECISION = TP / (TP + FP) || 0;
            const RECALL = TP / (TP + FN) || 0;
            const F1 = 2 * (PRECISION * RECALL) / (PRECISION + RECALL) || 0;
            
            const metricsHtml = `
                <p><strong>Accuracy:</strong> ${ACCURACY.toFixed(4)}</p>
                <p><strong>Precision (AI):</strong> ${PRECISION.toFixed(4)}</p>
                <p><strong>Recall (AI):</strong> ${RECALL.toFixed(4)}</p>
                <p><strong>F1 Score:</strong> ${F1.toFixed(4)}</p>
            `;
            document.getElementById('performance-metrics').innerHTML = metricsHtml;

            // Clean up Tensors
            trueLabels.dispose();
            predLabels.dispose();
            confusionMatrix.dispose();
        });
        
        // Update Confusion Matrix Title
        document.querySelector('#metrics-output .metric-card:last-child h3').innerText = `Confusion Matrix (Threshold: ${document.getElementById('threshold-value').innerText})`;
    };
    
    // ==================================================================================
    // Step 9: Export Results
    // ==================================================================================
    window.exportResults = async () => {
        if (!model || !testSequencesPadded) {
            updateStatus('export-status', 'Model or Test Data not ready.', true);
            return;
        }
        enableButton('export-btn', false);
        
        document.getElementById('export-status').innerText = 'Running predictions on test.csv and generating results CSV...';
        
        await tf.nextFrame();

        tf.tidy(() => {
            const threshold = parseFloat(document.getElementById('threshold-slider').value);
            const xTestRawTexts = testData.map(row => row[1]); 

            // Predict on the UNLABELED test data (test.csv)
            const testPredictions = model.predict(testSequencesPadded);
            // Get probabilities for class 1 (AI)
            const probAIArray = testPredictions.slice([0, 1], [-1, 1]).dataSync(); 

            let csv = "Text_Snippet,Prediction_Label (1=AI),Probability_AI\n";
            
            for (let i = 0; i < xTestRawTexts.length; i++) {
                // Sanitize text for CSV: remove commas and newlines, truncate
                const textSnippet = String(xTestRawTexts[i]).substring(0, 100).replace(/,/g, ' ').replace(/\n/g, ' '); 
                const predictionLabel = probAIArray[i] > threshold ? 1 : 0;
                const prob = probAIArray[i].toFixed(4);
                
                csv += `"${textSnippet}",${predictionLabel},${prob}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "prediction_results_test.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            testPredictions.dispose(); // Clean up tensor

            updateStatus('export-status', 'âœ… Export complete! Check your downloads folder.', false);
        });

        enableButton('export-btn', true);
    };

    // Ensure initial button states are correct on load
    window.onload = () => {
        // Initial setup for the threshold slider change event
        document.getElementById('threshold-slider').addEventListener('input', calculateMetrics);
        // Display initial value
        document.getElementById('threshold-value').innerText = parseFloat(document.getElementById('threshold-slider').value).toFixed(2);
    };

</script>
</body>
</html>
